from typing import Any, List, Optional, Union, Dict

import ioh.iohcpp as ic

class IntegerSingleObjective:
    problems: Dict[int, str] = ...  # read-only
    def __init__(
        self,
        name: str,
        n_variables: int,
        instance: int,
        is_minimization: bool,
        bounds: ic.IntegerBounds,
        constraints: ic.IntegerConstraint,
        optimum: ic.IntegerSolution,
    ) -> None: ...
    def attach_logger(self, logger) -> None: ...
    def create(
        self, id: Union[int, str], iid: int, dim: int
    ) -> IntegerSingleObjective: ...
    def detach_logger(self) -> None: ...
    def reset(self) -> None: ...
    def __call__(self, x: List[int]) -> float: ...
    def add_constraint(self, constraint: ic.IntegerConstraint) -> None: ...
    def remove_constraint(self, constraint: ic.IntegerConstraint) -> None: ...
    def enforce_bounds(
        self, weight: float, enforced: ic.ConstraintEnforcement, exponent: float
    ) -> None: ...
    @property
    def bounds(self) -> ic.IntegerBounds: ...
    @property
    def constraints(self) -> ic.IntegerConstraintSet: ...
    @property
    def log_info(self) -> ic.LogInfo: ...
    @property
    def meta_data(self) -> ic.MetaData: ...
    @property
    def optimum(self) -> ic.IntegerSolution: ...
    @property
    def state(self) -> ic.IntegerState: ...

class IntegerMultiObjective:
    problems: Dict[int, str] = ...  # read-only
    def __init__(
        self,
        name: str,
        n_variables: int,
        n_objectives: int,
        instance: int,
        is_minimization: bool,
        bounds: ic.IntegerBounds,
        constraints: ic.IntegerConstraint,
        optimum: ic.IntegerSolution,
    ) -> None: ...
    def attach_logger(self, logger) -> None: ...
    def create(
        self, id: Union[int, str], iid: int, dim: int
    ) -> IntegerMultiObjective: ...
    def detach_logger(self) -> None: ...
    def reset(self) -> None: ...
    def __call__(self, x: List[int]) -> float: ...
    def add_constraint(self, constraint: ic.IntegerConstraint) -> None: ...
    def remove_constraint(self, constraint: ic.IntegerConstraint) -> None: ...
    def enforce_bounds(
        self, weight: float, enforced: ic.ConstraintEnforcement, exponent: float
    ) -> None: ...
    @property
    def bounds(self) -> ic.IntegerBounds: ...
    @property
    def constraints(self) -> ic.IntegerConstraintSet: ...
    @property
    def log_info(self) -> ic.LogMultiInfo: ...
    @property
    def meta_data(self) -> ic.MetaData: ...
    @property
    def optimum(self) -> ic.MultiIntegerSolution: ...
    @property
    def state(self) -> ic.MultiIntegerState: ...

class RealSingleObjective:
    problems: Dict[int, str] = ...  # read-only
    def __init__(
        self,
        name: str,
        n_variables: int,
        instance: int,
        is_minimization: bool,
        bounds: ic.RealBounds,
        constraints: ic.RealConstraint,
        optimum: ic.RealSolution,
    ) -> None: ...
    def attach_logger(self, logger) -> None: ...
    def create(
        self, id: Union[int, str], iid: int, dim: int
    ) -> IntegerSingleObjective: ...
    def detach_logger(self) -> None: ...
    def reset(self) -> None: ...
    def __call__(self, x: List[float]) -> float: ...
    def add_constraint(self, constraint: ic.RealConstraint) -> None: ...
    def remove_constraint(self, constraint: ic.RealConstraint) -> None: ...
    def enforce_bounds(
        self, weight: float, enforced: ic.ConstraintEnforcement, exponent: float
    ) -> None: ...
    @property
    def bounds(self) -> ic.RealBounds: ...
    @property
    def constraints(self) -> ic.RealConstraintSet: ...
    @property
    def log_info(self) -> ic.LogInfo: ...
    @property
    def meta_data(self) -> ic.MetaData: ...
    @property
    def optimum(self) -> ic.RealSolution: ...
    @property
    def state(self) -> ic.RealState: ...

class RealMultiObjective:
    problems: Dict[int, str] = ...  # read-only
    def __init__(
        self,
        name: str,
        n_variables: int,
        n_objectives: int,
        instance: int,
        is_minimization: bool,
        bounds: ic.RealBounds,
        constraints: ic.RealConstraint,
        optimum: ic.RealSolution,
    ) -> None: ...
    def attach_logger(self, logger) -> None: ...
    def create(
        self, id: Union[int, str], iid: int, dim: int
    ) -> RealMultiObjective: ...
    def detach_logger(self) -> None: ...
    def reset(self) -> None: ...
    def __call__(self, x: List[float]) -> float: ...
    def add_constraint(self, constraint: ic.RealConstraint) -> None: ...
    def remove_constraint(self, constraint: ic.RealConstraint) -> None: ...
    def enforce_bounds(
        self, weight: float, enforced: ic.ConstraintEnforcement, exponent: float
    ) -> None: ...
    @property
    def bounds(self) -> ic.RealBounds: ...
    @property
    def constraints(self) -> ic.RealConstraintSet: ...
    @property
    def log_info(self) -> ic.LogMultiInfo: ...
    @property
    def meta_data(self) -> ic.MetaData: ...
    @property
    def optimum(self) -> ic.MultiRealSolution: ...
    @property
    def state(self) -> ic.MultiRealState: ...


class AbstractWModel(IntegerSingleObjective):
    def __init__(
        self,
        problem_id: int,
        instance: int,
        n_variables: int,
        name: str,
        dummy_select_rate: float = ...,
        epistasis_block_size: int = ...,
        neutrality_mu: int = ...,
        ruggedness_gamma: int = ...,
    ) -> None: ...
    def wmodel_evaluate(self, arg0: List[int]) -> int: ...

class AttractiveSector(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class BBOB(RealSingleObjective):
    ...



class BentCigar(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class BuecheRastrigin(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class ConcatenatedTrap(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class DifferentPowers(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Discus(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Ellipsoid(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class EllipsoidRotated(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Gallagher101(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Gallagher21(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class GraphProblem(IntegerSingleObjective): ...

class GriewankRosenBrock(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class IntegerWrappedProblem(IntegerSingleObjective):
    def __init__(self, *args, **kwargs) -> None: ...

class IsingRing(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class IsingTorus(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class IsingTriangular(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Katsuura(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LABS(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnes(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesDummy1(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesDummy2(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesEpistasis(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesNeutrality(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesRuggedness1(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesRuggedness2(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LeadingOnesRuggedness3(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Linear(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LinearSlope(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class LunacekBiRastrigin(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class MIS(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class MaxCoverage(GraphProblem):
    def __init__(self, instance: int, n_variables: int) -> None: ...
    def load_instances(self, path:str) -> None: ...

class MaxCut(GraphProblem):
    def __init__(self, instance: int, n_variables: int) -> None: ...
    def load_instances(self, path:str) -> None: ...

class MaxInfluence(GraphProblem):
    def __init__(self, instance: int, n_variables: int) -> None: ...
    def load_instances(self, path:str) -> None: ...

class NQueens(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMax(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxDummy1(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxDummy2(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxEpistasis(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxNeutrality(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxRuggedness1(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxRuggedness2(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class OneMaxRuggedness3(PBO):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class PBO(IntegerSingleObjective):
    ...

class PackWhileTravel(GraphProblem):
    def __init__(self, *args, **kwargs) -> None: ...
    def load_instances(self, *args, **kwargs) -> Any: ...

class Rastrigin(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class RastriginRotated(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class RealWrappedProblem(RealSingleObjective):
    def __init__(self, *args, **kwargs) -> None: ...

class Rosenbrock(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class RosenbrockRotated(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Schaffers10(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Schaffers1000(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Schwefel(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class SharpRidge(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class Sphere(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class StepEllipsoid(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class WModelLeadingOnes(AbstractWModel):
    def __init__(
        self,
        instance: int,
        n_variables: int,
        dummy_select_rate: float = ...,
        epistasis_block_size: int = ...,
        neutrality_mu: int = ...,
        ruggedness_gamma: int = ...,
    ) -> None: ...

class WModelOneMax(AbstractWModel):
    def __init__(
        self,
        instance: int,
        n_variables: int,
        dummy_select_rate: float = ...,
        epistasis_block_size: int = ...,
        neutrality_mu: int = ...,
        ruggedness_gamma: int = ...,
    ) -> None: ...

class Weierstrass(BBOB):
    def __init__(self, instance: int, n_variables: int) -> None: ...

def wrap_integer_problem(
    f: callable,
    name: str,
    optimization_type: ic.OptimizationType = ...,
    lb: Optional[float] = ...,
    ub: Optional[float] = ...,
    transform_variables: Optional[callable] = ...,
    transform_objectives: Optional[callable] = ...,
    calculate_objective: Optional[callable] = ...,
) -> None: ...
def wrap_real_problem(
    f: callable,
    name: str,
    optimization_type: ic.OptimizationType = ...,
    lb: Optional[float] = ...,
    ub: Optional[float] = ...,
    transform_variables: Optional[callable] = ...,
    transform_objectives: Optional[callable] = ...,
    calculate_objective: Optional[callable] = ...,
) -> None: ...

def wrap_integer_multi_problem(
    f: callable,
    name: str,
    optimization_type: ic.OptimizationType = ...,
    lb: Optional[float] = ...,
    ub: Optional[float] = ...,
    transform_variables: Optional[callable] = ...,
    transform_objectives: Optional[callable] = ...,
    calculate_objective: Optional[callable] = ...,
) -> None: ...

def wrap_real_multi_problem(
    f: callable,
    name: str,
    optimization_type: ic.OptimizationType = ...,
    lb: Optional[float] = ...,
    ub: Optional[float] = ...,
    transform_variables: Optional[callable] = ...,
    transform_objectives: Optional[callable] = ...,
    calculate_objective: Optional[callable] = ...,
) -> None: ...


class RealStarDiscrepancy(RealSingleObjective):
    def __init__(
        self,
        instance: int,
        n_variables: int,
        n_samples: int,
        sampler_type: ic.StarDiscrepancySampler,
    ) -> None: ...

class IntegerStarDiscrepancy(IntegerSingleObjective):
    def __init__(
        self,
        instance: int,
        n_variables: int,
        n_samples: int,
        sampler_type: ic.StarDiscrepancySampler,
    ) -> None: ...


class CEC2013(RealSingleObjective):
    n_optima: int

class EqualMaxima(CEC2013):
    ...

class FivePeaks(CEC2013):
    ...

class ModifiedRastrigin(CEC2013):
    ...

class Shubert(CEC2013):
    ...

class SixHumpCamelback(CEC2013):
    ...

class UnevenEqualMaxima(CEC2013):
    ...

class Vincent(CEC2013):
    ...

class CEC2013CompositionFunction(CEC2013):
    ...

class CEC2022(RealSingleObjective):
    ...

class CEC2022Zakharov(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022Rosenbrock(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022SchafferF7(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022Rastrigin(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022Levy(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022HybridFunction1(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022HybridFunction2(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022HybridFunction3(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022CompositionFunction1(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022CompositionFunction2(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022CompositionFunction3(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...

class CEC2022CompositionFunction4(CEC2022):
    def __init__(self, instance: int, n_variables: int) -> None: ...
    